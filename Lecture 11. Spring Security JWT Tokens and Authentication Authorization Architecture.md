 

#### **Spring Security**

Spring Security is a framework within the Spring ecosystem designed to secure applications. It provides features for authentication, authorization, and protection against common vulnerabilities like CSRF attacks.

**Key Features:**

1. **Authentication:** Validating user credentials.
2. **Authorization:** Restricting access to resources based on roles/permissions.
3. **CSRF Protection:** Mitigates cross-site request forgery attacks.
4. **Session Management:** Ensures secure handling of user sessions.
5. **Integration with Spring Boot:** Simplified configuration via `application.properties` or `application.yml`.

**Core Components:**

- **SecurityFilterChain:** A chain of filters that intercepts HTTP requests to enforce security policies.
- **AuthenticationManager:** Handles user authentication by verifying credentials against a `UserDetailsService` or an external provider.
- **AccessDecisionManager:** Evaluates if a user has the required permission to access a resource.
- **UserDetailsService:** Loads user-specific data (like username, password, and roles) from a persistent storage.

**Customization:** Spring Security is highly customizable:

- **Custom Authentication Providers:** Implement custom login mechanisms.
- **Custom Filters:** Add your security logic to the filter chain.
- **Method-Level Security:** Annotate methods with `@PreAuthorize` or `@PostAuthorize`.

---

#### **JWT Tokens**

**JWT (JSON Web Token)** is a compact, self-contained token used for securely transmitting information between parties.

**Structure:** A JWT consists of three parts, encoded as Base64 strings:

1. **Header:** Contains metadata like the algorithm used (e.g., `HS256`).
2. **Payload:** Contains claims (data about the user or session). Claims are of two types:
    - **Registered claims:** Standard claims like `iss` (issuer), `exp` (expiration), and `sub` (subject).
    - **Custom claims:** Application-specific claims like user roles.
3. **Signature:** Used to verify the integrity of the token. It's generated by hashing the header and payload using a secret key.

**Example JWT:**

```plaintext
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.eyJzdWIiOiJ1c2VyMTIzIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNjE2MjM5MDIyfQ
.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

**Benefits of JWT:**

- Stateless: No need to store tokens on the server.
- Secure: Claims are tamper-proof due to the signature.
- Compact: Easily transmitted in HTTP headers or cookies.

**Use Case:**

- JWTs are typically used in **token-based authentication systems**, where the client stores the JWT and sends it with each request to authenticate.

---

#### **Authentication and Authorization Architecture**

##### **Authentication Flow:**

1. **Login Request:**
    - The client sends credentials (e.g., username and password) to an authentication endpoint.
2. **Verification:**
    - Spring Security validates the credentials using the `AuthenticationManager` and `UserDetailsService`.
3. **Token Generation (JWT):**
    - Upon successful authentication, the server generates a JWT containing user information and returns it to the client.
4. **Token Storage:**
    - The client stores the JWT (e.g., in localStorage or cookies).
5. **Authenticated Requests:**
    - The client includes the JWT in the `Authorization` header (`Bearer <token>`) for all subsequent requests.

##### **Authorization Flow:**

1. **Extract Token:**
    - Spring Security extracts the token from the request header.
2. **Validate Token:**
    - The token is validated (e.g., signature, expiration time).
3. **Load User Details:**
    - The user’s roles and permissions are retrieved based on the claims in the token.
4. **Access Decision:**
    - The `AccessDecisionManager` checks if the user is authorized to access the requested resource.

---

#### **End-to-End Authentication and Authorization Architecture**

1. **Frontend:**
    - Provides login forms and securely stores JWTs.
    - Attaches JWT to requests needing authentication.
2. **Backend:**
	1. Filter / interceptor
	    - Acts as the first line of defense. Validates JWTs before forwarding requests to controllers.
	    - Handles login, token generation, and user management.
	    - Maintains user data in a database or integrates with external providers (e.g., OAuth, LDAP).
	    -  Decodes and verifies JWT tokens using a shared secret or public key.
	    - Enforces role-based access control (RBAC) for specific endpoints.
	2. **Controllers**
	3. **Database:**

---

#### **Advantages of the JWT-Based Architecture:**

- **Scalability:** Stateless design fits well with microservices.
- **Performance:** No need for server-side session management.
- **Decoupled Services:** Easy integration with third-party systems.

### JWT Authentication Flow

#### **1. HTTP Request Intercepts at `JwtAuthFilter`**

When a client sends an HTTP request, it includes the JWT in the `Authorization` header in the format:  
`Authorization: Bearer <jwt_token>`.

- **Responsibilities:**
    
    - Extract the token from the `Authorization` header.
    - Pass the token for validation or handle missing/invalid tokens.
- **Cases:**
    
    1. **No Token Provided:**
        - The filter identifies that the request does not contain a token.
        - Responds with HTTP 401 Unauthorized.
    2. **Malformed Token:**
        - If the token is improperly formatted (e.g., missing parts or not Base64-encoded), the filter blocks the request.
        - Responds with HTTP 400 Bad Request.

---

#### **2. Fetch User from Database**

After extracting the token, the filter decodes it and parses the claims (e.g., `username` or `user_id`). Using this identifier, the filter fetches user details from the database.

- **Responsibilities:**
    - Retrieve user information such as roles, permissions, or account status.
    - Handle cases where the user is not found.
- **Cases:**
    1. **User Found:**
        - Proceed to token validation.
    2. **User Not Found:****
        - If the user no longer exists in the system (e.g., account deleted), respond with HTTP 401 Unauthorized.
        - Optionally log or alert for potential anomalies (e.g., token tampering).

---

#### **3. Validate the Token**

The token is validated for:

- **Signature:** Ensure the token's signature matches using the server's secret or public key.
    
- **Expiration:** Check if the `exp` claim has expired.
    
- **Additional Claims:** Validate custom claims such as roles or issued-at (`iat`) times.
    
- **Responsibilities:**
    
    - Verify token integrity and validity.
    - Handle expired or tampered tokens.
- **Cases:**
    
    1. **Valid Token:**
        - If the token is valid, proceed to update the security context.
    2. **Expired Token:**
        - If the token's expiration time (`exp`) has passed:
            - Respond with HTTP 401 Unauthorized.
            - Optionally include a message like "Token expired" and guide the user to refresh their session.
    3. **Tampered Token:**
        - If the signature does not match:
            - Respond with HTTP 401 Unauthorized.
            - Log the event for potential security threats.

---

#### **4. Update the `SecurityContext`**

The `SecurityContext` is Spring Security’s way of managing the currently authenticated user. After token validation:

- Fetch user roles and permissions from the database or token claims.
    
- Create an `Authentication` object (e.g., `UsernamePasswordAuthenticationToken`) to represent the authenticated user.
    
- Set this object in the `SecurityContextHolder`.
    
- **Responsibilities:**
    
    - Ensure the `SecurityContext` is properly populated for downstream use (e.g., in controllers).
    - Handle cases where roles or permissions are insufficient.
- **Cases:**
    
    1. **User Authorized:**
        - If the user has sufficient roles/permissions, allow the request to proceed.
    2. **User Not Authorized:**
        - If the user does not have the necessary roles, respond with HTTP 403 Forbidden.

---

#### **5. Forward Request to Controller**

After the `SecurityContext` is updated, the request is forwarded to the appropriate controller or handler.

- **Responsibilities:**
    
    - Handle the request as an authenticated user.
    - Perform additional validations or business logic.
- **Cases:**
    
    1. **Authenticated and Authorized:**
        - The controller processes the request successfully.
        - Respond with HTTP 200 OK or other success codes.
    2. **Unexpected Issues:**
        - Handle any exceptions or errors within the controller, e.g., insufficient permissions or missing data.
        - Respond with appropriate HTTP error codes.

---

### **Summary of Token Scenarios**

|**Step**|**Token State**|**Action**|**HTTP Response**|
|---|---|---|---|
|**Extraction**|No Token|Block the request|401 Unauthorized|
||Malformed Token|Block the request|400 Bad Request|
|**User Lookup**|User Found|Proceed to validation|N/A|
||User Not Found|Block the request|401 Unauthorized|
|**Validation**|Valid Token|Proceed to update `SecurityContext`|N/A|
||Expired Token|Block the request|401 Unauthorized|
||Tampered Token|Block the request|401 Unauthorized|
|**SecurityContext Update**|Authorized User|Forward to controller|N/A|
||Unauthorized User|Block the request|403 Forbidden|
|**Controller**|Request Valid|Process successfully|200 OK|
||Invalid Request|Return appropriate error|Depends on error context|

By handling each of these cases systematically, your application ensures a robust and secure authentication and authorization flow.



![[Pasted image 20241207181219.png]]

